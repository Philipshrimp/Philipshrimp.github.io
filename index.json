[{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":["NeRF"],"contents":"\n이 논문은 적은 양의 입력으로도 NeRF를 수행할 수 있는 방법을 제안하고 있다. 위 동영상은 4장의 입력만으로 NeRF를 돌린 결과인데, 4장의 이미지에서 저런 일반화된 뉴럴 렌더링 결과가 나왔다는 사실이 굉장히 놀라웠다. \nMotivation 이 논문의 목적은 Entropy 개념을 이용하여 regularization을 시도하는 것이다. 다른 별도의 모듈을 추가하거나, 학습을 추가하는 등의 복잡한 기법을 추가한 것이 아닌 정보 이론 개념을 활용한 loss term 추가만으로 이를 가능하게 했다는 점이 핵심이며, 이 덕분에 다른 많은 NeRF 모듈에 해당 방법을 붙이기 쉽게 적용할 수 있다고 한다. 추가로 유사도가 높은 viewpoint에서의 학습이 문제가 되어(Overfitting) 이에 대해 information gain을 추가 제안하고 있다. 이 두 가지 term을 loss에 추가하면서 결과적으로 train 당시 보지 못한 view에 대해서도 noise가 줄어든 결과를 얻을 수 있었다. \n 논문의 appendix에서는 이를 그래프로써 표현하며 부연설명을 하고 있다. NeRF에서, 처음에 100개의 view에 대한 이미지를 입력으로 넣었을 때는 상대적으로 많이 낮게 나왔던 density의 entropy나 information gain이 4개 view로 줄어들자 크게 높아진 것을 볼 수 있다. InfoNeRF에서는 이 두 부분을 loss term으로 추가함으로써 해당 값들을 최소화 해 여러 view에서 높은 정확도로 density를 추정하도록 한다.\nRegularization by Ray Entropy Minimization 먼저 논문에서는 ray density를 normalize하여 확률처럼 접근할 수 있도록 바꾸었다.\n$$ p(\\textbf{r}_i) = \\frac{\\alpha_i}{\\sum_j\\alpha_j} = \\frac{1-\\exp(-\\sigma_i\\delta_i)}{\\sum_j(1-\\exp(-\\sigma_j\\delta_j))} $$\r\r\n여기서 \\(\\alpha\\)는 렌더링에서의 불투명도(opacity)를 의미한다. ray 내에 특정 sampled point의 density를 기반으로 이렇게 불투명도를 표현하고 있는데, 주로 이 표현은 volumetric rendering에서 많이 표현하는 부분이기도 하다. 수식을 해석하자면, 하나의 ray로부터 나온 모든 sampled point들의 density를 기준으로 하나의 sampled point를 normalize하고 있는 것이다. 이를 하나의 확률로써 간주하고, 이 각각의 sampled point의 density에 대한 entropy를 수식으로 표현하면 다음과 같다.\n$$ H(\\textbf{r}) = \\sum^N_{i=1}p(\\textbf{r}_i)\\log{p(\\textbf{r}_i)} $$\r\r\n하나의 ray상에 있는 전체 density를 기준으로 entropy를 구하고 있는데, 이론 그대로 보자면 density 값이 일부 확실한 영역에만 높게 나왔다면 이 entropy 값은 낮을 것이고, 결과적으로 해당 영역에 확실하게 렌더링을 수행할 것이다. 반면, 여러 영역 여기저기에 density 값이 높다면 entropy 값은 크게 나올 것이다. 즉, 해당 ray에서의 렌더링을 진행하기 위한 확실성이 떨어짐을 의미하는 것이다. 결과적으로 이 부분에서는 entropy 값이 낮게 나오도록 유도하는 것이 핵심이다. \n그러나 단순히 이 이론대로 진행하기에는 일부 ray에서 non-hitting case임에도 불구하고 low entropy가 나오도록 강요되는 경우가 있었다고 한다. 이러한 경우에는 잠재적인 artifact 생성의 문제를 야기하게 된다. 논문에서는 이러한 부분을 완화하기 위해 마스크를 적용해서 low density를 갖는 영역을 무시하고 진행하도록 한다.\n$$ M(\\textbf{r}) = \\begin{cases} 1, \u0026amp; Q(\\textbf{r}) \u0026gt; \\epsilon \\\\ 0, \u0026amp; otherwise \\end{cases}$$\r\r 여기서 Q는 하나의 ray에서 sample한 N개의 point에 대한 누적 불투명도를 의미한다. 이 누적 불투명도가 특정 임계치를 초과하면 유효한 영역으로, 그렇지 않을 경우에는 무시할 영역으로 간주한다. 이를 기반으로 최종적인 ray entropy loss를 정의하면 다음과 같다.\n$$ L_{entropy} = \\frac{1}{|R_s|+|R_u|}\\sum_{\\textbf{r}\\in R_s\\bigcup R_u}M(\\textbf{r})\\odot H(\\textbf{r}) $$\r\r\n특이한 점은 loss를 계산하기 위한 대상으로 trained image의 ray set과 unseen image의 ray set을 사용한다고 논문에서 설명한다. 이 부분이 이해가 되지 않았는데, trained image는 보통 학습 입력으로 넣는 이미지의 view를 생각하면 되고, unseen image는 그와는 다른 viewpoint에서 쏜 ray를 생각하면 된다고 한다. 보통 NeRF는 L2 Norm 기반의 rendering loss를 계산하기 때문에 이러한 unseen ray를 활용할 수 없는데, entropy loss는 별도의 ground truth를 요구하는 것이 아닌 불확실성을 낮추는 loss이기 때문에 이게 가능했다고 한다. \nRegularization by Information Gain Reduction 만약 모든 트레이닝 이미지가 유사한 뷰를 가지고 있다면, 모델 오버피팅이 발생할 것이며, 이는 unseen image에 대한 일반화를 어렵게 한다. 이에 본 논문에서는 Information gain을 기반으로 하여 이웃한 ray들 간 일관된 density distribution을 보장할 수 있는 추가 loss 제안한다. 주어진 기준 ray에 대해 viewpoint가 미묘하게 다른(논문에서는 5도 정도의 rotation 차이를 주고 있음) viewpoint를 선정하여 그 시점에서부터 ray를 sampling한다. Information Gain Loss는 이러한 두 ray 간의 normalized density를 KL-Divergence를 기반으로 둘 간의 차이 계산을 수행한다. 본 term의 목적은 둘 간의 차이를 최소화하는 것이다. 이 방법을 통해 논문에서는 인접한 viewpoint들끼리 일반화를 가능하게 했다고 주장한다.\n$$ L_{KL} = \\sum^N_{i=1}p(\\textbf{r}_i)\\log\\frac{p(\\textbf{r}_i)}{p(\\tilde{\\textbf{r}}_i)} $$\r\r\nOverall Objective $$ L_{Total} = L_{RGB} + \\lambda_1L_{entropy} + \\lambda_2L_{KL} $$\r\r 최종 loss function은 위 공식처럼 정의할 수 있다. 원래 NeRF에서 사용하던 Rendering loss에다가 entropy loss와 information gain loss를 일정 가중치를 주어서 계산한다. 여기서 rendering loss는 ground truth image를 기반으로 계산하는 supervised loss이며, 나머지 두 loss는 확률의 차이와 불확실성 자체를 낮추는 loss이기 때문에 unsupervised loss로 볼 수 있다. \nExperimental results  위 표는 360도 synthetic data로부터 4개의 view를 샘플링하여 novel view synthesis를 수행한 결과를 나타낸다. (cont\u0026rsquo;d)\n","date":"February 24, 2023","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/posts/nerf/infonerf/","summary":"이 논문은 적은 양의 입력으로도 NeRF를 수행할 수 있는 방법을 제안하고 있다. 위 동영상은 4장의 입력만으로 NeRF를 돌린 결과인데, 4장의 이미지에서 저런 일반화된 뉴럴 렌더링 결과가 나왔다는 사실이 굉장히 놀라웠다. \nMotivation 이 논문의 목적은 Entropy 개념을 이용하여 regularization을 시도하는 것이다. 다른 별도의 모듈을 추가하거나, 학습을 추가하는 등의 복잡한 기법을 추가한 것이 아닌 정보 이론 개념을 활용한 loss term 추가만으로 이를 가능하게 했다는 점이 핵심이며, 이 덕분에 다른 많은 NeRF 모듈에 해당 방법을 붙이기 쉽게 적용할 수 있다고 한다.","tags":["Deep Learning","Neural Network","Neural Rendering","NeRF","Information Theory","Few-shot NeRF"],"title":"InfoNeRF: Ray Entropy Minimization for Few-Shot Neural Volume Rendering"},{"categories":["NeRF"],"contents":"해당 논문에 대한 리뷰 영상은 아래 동영상을 통해서도 확인하실 수 있습니다.   \nIntro  \nOriginal NeRF 논문은 처음 ECCV 2020에서 발표되었을 때, 뉴럴 렌더링 부분에 있어 굉장히 큰 화두가 되었다. 그와 동시에 많은 한계점들을 가지고 있어서 많은 연구자들로부터 그 문제점들이 지속적으로 지적되어 왔다. 이번에 리뷰할 BARF 논문에서는 그 중에서 Original NeRF가 입력 데이터로 정확한 Camera pose를 요구하고 있다는 점을 지적하고 있는데, 다시 말하면 입력 이미지 데이터와 한 쌍으로 있을 transformation 값이 부정확하거나 알 수 없을 경우에는 뉴럴 렌더링의 정확도가 떨어지게 된다는 것이다. BARF는 이러한 문제를 해결할 수 있는 방안을 제시하고 있다. 이 논문에서는 부정확한 camera pose 오차를 줄이고, 동시에 본래 NeRF가 수행해야 하는 3차원 representation 정확도도 확보할 수 있는 파이프라인을 제안하며, 언급한 두 문제를 동시에 풀고자 한다. \n추가로 논문에서는 Positional encoding의 문제점도 지적하고 있다. 이전에 NeRF에서 입력 데이터를 고차원으로 encoding할 수 있게 해주는 positional encoding 방법은 representation 정확도 측면에서는 디테일을 잘 살려준다는 장점이 있으나, BARF에서처럼 representation과 pose registration을 동시에 수행하고자 할 때, pose registration 측면에서 정확도가 떨어지는 문제가 발생했다고 한다. BARF에서는 이러한 문제점 또한 완화시키기 위해 이러한 positional encoding을 coarse-to-fine 방식으로 접근하고 있다. \n기본적인 아이디어는 고전적인 Image alignment에서 출발해서 제안을 하고 있고, 이러한 방법으로 실험을 진행했을 때, BARF가 neural scene representation 문제와 large camera pose misalignment 문제를 동시에 잘 해결하고 있다고 주장한다. 결론적으로 이러한 점은 view synthesis와 localization 문제를 동시에 풀 수 있게 한다고 하고 있다. \nImage alignment 통상적으로 Image alignment는 특정 source image를 target view로 warping하는 것을 말하며, 여기서 발생하는 reprojection error를 최소화하는 것이 목표다. 논문에서는 이 reprojection error를 다음과 같은 수식으로 표현하고 있다.\n$$ \\min_\\textbf{p}\\sum_\\textbf{x}||I_1(W(\\textbf{x};\\textbf{p}))-I_2(\\textbf{x})||^2_2$$\r\r\n2차원 이미지 상에 있는 픽셀의 위치를 \\(\\textbf{x}\\)라고 할 때, source to target warping parameter \\(\\textbf{p}\\)를 이용하여 warping을 한 결과를 target과 비교하는 공식으로, 이 오차가 적을 수록 warping이 성공적으로 되었다고 볼 수 있다. (참고로 여기서 언급하는 warping은 컴퓨터 비전에서의 affine transform, homography와 같은 문제를 생각하면 좋다.) 최적화 관점에서 이 파라미터는 점진적인 update를 하며 최적의 값을 찾아나가기 때문에 매 term마다 아래의 변화량을 얻게 되고, 이 변화량을 더하여 파라미터를 갱신하는 형태로 진행한다.\n$$ \\Delta\\textbf{p} = -A(\\textbf{x};\\textbf{p})\\sum_\\textbf{x}\\textbf{J}(\\textbf{x};\\textbf{p})^T(I_1(W(\\textbf{x};\\textbf{p}))-I_2(\\textbf{x}))$$\r\r\n논문에서는 \\(A\\)를 Generic transformation matrix라고 언급하고 있다. 이 Generic transformation matrix는 최적화 기법에 따라서 들어가는 값이 다르다고 하는데, 보통 Gauss-Newton method를 생각하면 이 자리에 Hessian 값이 들어가서 \\(A(\\textbf{x};\\textbf{p})=(\\sum_\\textbf{x}\\textbf{J}(\\textbf{x};\\textbf{p})^T\\textbf{J}(\\textbf{x};\\textbf{p}))^{-1}\\)로 정의된다고 한다. 최근의 딥 러닝 기술에서는 이렇게 2차 미분 형태의 Hessian까지 접근하기 보다는 first-order optimizer 방법을 사용하는 것이 더 선호된다고 하는데(Gradient descent), 이 경우의 A 값은 스칼라 값으로 정의한다고 한다. 딥 러닝에서 쓰고 있는 learning rate가 이 자리에 들어간다고 논문에서는 이야기한다. Steepst descent image term을 의미하는 J의 경우, Image에 대한 1차 미분(=Jacobian)으로 이해할 수 있는데, 보통 이미지의 Jacobian이라면 \\(\\textbf{J}(\\textbf{x};\\textbf{p})=\\frac{\\partial I(\\textbf{x})}{\\partial\\textbf{x}}\\)이라고 할 수 있을 것이다. 그러나 warped image 관점에서 보면 각 픽셀 좌표 값들이 잘 warp되었는지 검증이 필요하고, 이를 위해서는 warping parameter가 최적의 값을 가져야만 한다. 이로 인해 여기서의 Jacobian은 아래와 같이 정의하고 있다.\n$$ \\textbf{J}(\\textbf{x};\\textbf{p}) = \\frac{\\partial I_1(W(\\textbf{x};\\textbf{p}))}{\\partial W(\\textbf{x};\\textbf{p})} \\frac{\\partial W(\\textbf{x};\\textbf{p})}{\\partial\\textbf{p}}$$\r\r\n식을 보면 원래의 Jacobian 식처럼 \\(\\textbf{x}\\)에 대해서 편미분하는 것이 아닌, 워핑된 좌표 결과에 대해 편미분하는 것을 볼 수 있다. 이어서 이 워핑된 결과 자체에 대해서도 파라미터에 대해 편미분을 하는 모습을 볼 수 있는데, 식 자체는 마치 chain rule 형태처럼 이루어진 것을 볼 수 있다. 이런 식으로 식을 구성한 이유는 warping parameter를 딥 러닝 관점에서 바라볼 때, 학습의 대상이 되기 때문에 역전파 과정에서 이를 학습하기 위한 형태로 표현하고자 이렇게 접근한 것이 아닐까 싶었다. 참고로 \\(\\frac{\\partial W(\\textbf{x};\\textbf{p})}{\\partial\\textbf{p}}\\)는 사전에 정의된 warping에 대한 pixel의 변위를 의미한다고 한다. \nImage alignment as neural networks 지금까지 언급한 설명이 통상적인 Image alignment에 대한 내용이라면, 이번에는 이 개념을 뉴럴 네트워크의 측면에서 바라보는 설명을 하고 있다. 앞서서 Image alignment에서는 reprojection error를 최소화 할 최적의 warping parameter p를 찾아야 한다고 했는데, 이제 이걸 뉴럴 네트워크의 메커니즘처럼 학습을 통해 최적의 값으로 수렴해나가는 방식으로 접근을 한다. 나아가서 warped image를 만들어내는 과정 전체를 뉴럴 네트워크를 통해서 진행한다고 가정하면, warping parameter도 중요하지만, 실제로 만들어지는 이미지의 representation 또한 target과 유사도가 높아야 한다. 그렇기 때문에 여기서는 image alignment가 만들어내는 이미지 자체의 유사도와 alignment 내에서 진행되는 warping의 정확도를 동시에 확보해야 한다. 이에 대한 목적 함수는 다음과 같이 나타낼 수 있다.\n$$ \\min_{\\textbf{p},\\Theta}\\sum_\\textbf{x}(||f(\\textbf{x};\\Theta)-I_1(\\textbf{x})||^2_2 + ||f(W(\\textbf{x};\\textbf{p});\\Theta)-I_2(\\textbf{x})||^2_2) $$\r\r\n여기서의 함수 f가 뉴럴 네트워크를 의미한다. 이 문제를 alignment를 수행해야하는 이미지가 두 개고, 그 두 이미지 각각에 대한 ground truth가 있는 환경에서의 image alignment로써 다음과 같이 정의할 수도 있다.\n$$ \\min_{p_1,p_2,\\Theta}\\sum^2_{i=1}\\sum_\\textbf{x}||f(W(\\textbf{x};\\textbf{p}_i);\\Theta)-I_i(\\textbf{x})||^2_2 $$\r\r\n이 식을 더 확장해서 보면, 이미지 M개의 alignment 문제에 대해서도 이 식으로 풀 수 있다는 뜻이 되고, 이에 대한 warping parameter도 함께 M개로 늘어날 것임을 알 수 있다. \nNeural Radiance Fields 이제 앞서 설명한 Image alignment 컨셉을 3차원으로 확장하여 NeRF에 해당 이론을 적용하여보자. 2차원에서 3차원으로 확장된 만큼, 앞서 언급한 warping parameter는 3D rigid transformation을 위한 파라미터로 간주될 수 있을 것이다. 그리고 앞서 뉴럴 네트워크라고 언급한 함수 f는 NeRF가 될 것이다. NeRF는 MLP layer를 통해 3차원 입력 좌표와 viewing direction이 들어가면 이에 상응하는 color와 density 값을 출력하는데, 이를 수식으로 표현하면 \\(y=[\\textbf{c};\\sigma]=f(\\textbf{x};\\Theta)\\)와 같이 볼 수 있다(논문에서는 간소화를 위해 viewing direction이 생략되어 있어 이후 언급되는 식에서는 viewing direction이 생략되어 표기됩니다. 물론 viewing direction은 계속 고려되고 있습니다!). 여기서 NeRF 과정을 y=f(x)꼴로 표기를 했는데, 여기서 확장해서 논문에서는 volumetric rendering 문제를 또 합성함수의 형태로 정리하고 있다. NeRF에서 사용하던 Volumetric rendering 공식을 pixel homogeneous coordinates 관점에서 보면 다음과 같이 표기할 수 있다.\n$$ \\hat{I}(\\textbf{u}) = \\int_{z_{near}}^{z_{far}}T(\\textbf{u},z)\\sigma(z\\bar{\\textbf{u}})\\textbf{c}(z\\bar{\\textbf{u}})dz$$\r\r\n이 식은 픽셀 좌표계에 있는 2차원 좌표 \\(\\textbf{u}\\)와 이를 homogeneous coordinates로 변환한 \\(\\bar{\\textbf{u}}\\), 그리고 depth 값으로 간주할 수 있는 ray에서의 step z에 대한 표현으로 나타내고 있다. 앞서 y=f(x)를 통해 얻은 3차원 포인트의 representation이 y에 담겨있다고 할 때, 포인트 y가 N개가 있다라고 하면 volumetric rendering은 다음과 같은 함수 형태로 나타낼 수 있다.\n$$ \\hat{I}(\\textbf{u}) = g(\\textbf{y}_1, \\textbf{y}_2, \u0026hellip;, \\textbf{y}_N)$$\r\r\n여기서 카메라 좌표계상에 있는 픽셀 좌표를 depth step에 따라 3차원 월드 좌표계로 transform하는 함수가 \\(W(z\\bar{\\textbf{u}};\\textbf{p})\\)라고 할 때, \\(y=f(W(z\\bar{\\textbf{u}};\\textbf{p});\\Theta)\\)라고 할 수 있으며, 이에 따라서 위의 렌더링 공식은 다음과 같은 합성 함수 형태로 정리될 수 있다.\n$$ \\hat{I}(\\textbf{u};\\textbf{p}) = g(f(W(z_1\\bar{\\textbf{u}};\\textbf{p});\\Theta), f(W(z_2\\bar{\\textbf{u}};\\textbf{p});\\Theta), \u0026hellip;, f(W(z_N\\bar{\\textbf{u}};\\textbf{p});\\Theta))$$\r\r\n이 식을 통해 transformed image가 2차원 pixel 좌표와 transformation parameter에 대하여 정리됨을 볼 수가 있다. 앞서 Image alignment 말미에 정리한 공식으로 돌아가자. 해당 식은 여러 개의 warping parameter와 representation parameter를 최적화하여 목적 함수를 최소화하는 쪽으로 학습이 되어야 한다고 했다. 동일 공식을 NeRF의 Volumetric rendering에 적용하면 다음과 같이 표기할 수도 있다. 이미지 입력 M개가 있다고 할 때, NeRF는 아래의 식을 최소화해야 한다.\n$$ \\min_{p_1,\u0026hellip;,p_M,\\Theta}\\sum^M_{i=1}\\sum_\\textbf{u}||\\hat{I}(\\textbf{u};\\textbf{p}_i,\\Theta)-I_i(\\textbf{u})||^2_2 $$\r\r\n이 식을 통해 NeRF의 volumetric rendering에 대해 각 이미지 별 M개의 pose와 representation을 동시에 최적화하도록 유도했다. 그런데 앞서 Image alignment를 설명할 때, warping parameter update를 위한 Jacobian을 정리한 부분이 있었다. parameter의 delta 값을 얻기 위해 1차 미분으로 접근하였기 때문인데, NeRF에서 또한 transformation parameter update를 위해서는 gradient descent 기반의 접근이 필요하고, 이를 위해서는 steepest descent image term이 요구되고 있다. N개의 위치 값에 대한 Jacobian 식은 다음과 같이 정의할 수 있다.\n$$ \\textbf{J}(\\textbf{u};\\textbf{p}) = \\frac{\\partial g(\\textbf{y}_1, \\textbf{y}_2, \u0026hellip;, \\textbf{y}_N)}{\\partial \\textbf{y}_i} \\frac{\\partial \\textbf{y}_i(\\textbf{p})}{\\partial \\textbf{x}_i(\\textbf{p})} \\frac{\\partial W(z_i\\bar{\\textbf{u}};\\textbf{p})}{\\partial\\textbf{p}}$$\r\r\n이 식은 렌더링 함수인 \\(g(\\textbf{y}_1, \\textbf{y}_2, \u0026hellip;, \\textbf{y}_N)\\)를 편미분하고 있는 것을 알 수가 있는데, 렌더링 함수를 representation 결과인 y에 대해서 미분하고, 거기에 neural network의 Jacobian을 곱한 뒤 transformation 함수에 대한 pixel 변위를 곱하고 있다. 이 Jacobian 역시 chain rule 형태로 정의되어 있는 것을 볼 수가 있다. 이를 통해 네트워크에서 효율적인 pose update 파이프라인을 구성할 수 있었다. \nOn Positional Encoding and Registration 다음으로는 지금까지 정의된 BARF 파이프라인에 Original NeRF에서 사용하고 있는 Positional encoding을 적용하고 있다. 보통 (k, k+1)번째 차원에 대한 positional encoding 결과는 다음과 같은 함수로 표현할 수 있다.\n$$ \\gamma_k(\\textbf{x}) = [\\cos(2^k\\pi\\textbf{x}), \\sin(2^k\\pi\\textbf{x})] $$\r\r\n이 식을 x에 대해 미분을 하면\n$$ \\frac{\\gamma_k(\\textbf{x})}{\\textbf{x}} = 2^k\\pi[-\\sin(2^k\\pi\\textbf{x}), \\cos(2^k\\pi\\textbf{x})] $$\r\r\n로 정리될 수 있는데, 이걸 그래프 형태로 보면 동일 frequency에서 signal 증폭이 일어난 꼴로 표현된다. 근데 여기서 이 signal 증폭이 문제가 되고 있다고 한다. 신호가 동일 주파수에서 증폭될 경우 signal 자체도 일관성이 점차 떨어지게 되고, ray별 증폭이 일어난다고 봤을 때, 이러한 증폭으로 인해 서로 다른 ray에서 같은 값을 갖는 positional encoding 결과가 발생할 수 있는데, 이로 인해 signal 간의 상쇄 현상도 발생한다. 이 문제가 이전에 representation detail 살리는 측면에서는 문제가 되지 않았으나, 정확한 pose 추정의 측면에서는 효율적인 update를 방해하는 문제가 있었다고 한다. 그래서 저자는 pose registration과 representation을 동시에 고려하는 BARF에서 positional encoding은 마치 양날의 검과 같은 존재라고 언급하고 있다. \nBundle-Adjusting Neural Radiance Fields 논문에서는 이러한 문제를 매우 간단한 접근으로 해결하고 있다. 마치 low-pass filter 컨셉과 같은 smoothing mask를 적용해서 처음에는 저차원의 encoding 결과에만 집중하고, 후반부로 갈 수록 고차원의 결과까지 모두 집중하는 접근법을 적용하였다. 이를 위해 원래의 positional encoding 함수인 \\(\\gamma_k(\\textbf{x}) = [\\cos(2^k\\pi\\textbf{x}), \\sin(2^k\\pi\\textbf{x})]\\)에다가 하나의 weight를 추가하였다.\n$$ w_k(\\alpha) = \\begin{cases} 0, \u0026amp; \\alpha \u0026lt; k \\\\ \\frac{1-\\cos((\\alpha-k)\\pi)}{2}, \u0026amp; 0 \\le \\alpha-k \u0026lt; 1 \\\\ 1, \u0026amp; \\alpha-k \\ge 1 \\end{cases}$$\r\r\n여기서 정의한 가중치를 점진적으로 증가시키면서 positional encoding이 초점을 맞추는 차원을 원본 이미지 차원에서 출발하여 Full positional encoding을 위해 설정한 L에 비례한 차원까지 확대시키는 방식인데, 이를 위해서 \\(\\alpha\\) 값을 iteration step에 비례하게 점진적으로 증가시키면서 weight를 부여하고 있다. 이 방법으로 인해 BARF는 초기에는 smooth signal에 대해서 보고, 뒤로 갈 수록 높은 정확도의 표현력을 위한 쪽으로 학습되도록 하게 초점을 맞추어 준다. 즉, 초기에는 coarse하게 pose registration을 하고 나중에는 fine하게 scene representation을 하는 방법이다. \nExperimental results 먼저 논문에서는 Image alignment 성능의 검증을 위해 원본 고양이 이미지를 5개의 패치로 crop하여 이에 대한 alignment를 진행한 결과를 보여주고 있다.   \r 영상의 결과는 왼쪽부터 NeRF를 그냥 돌린 것과 NeRF에 Full positional encoding을 돌린 것, 그리고 제안한 BARF를 돌린 결과를 순차적으로 보여주고 있다. 최종적인 결과를 놓고 보면 BARF가 alignment와 representation을 가장 깔끔하게 한 것을 볼 수가 있다. 그러나 영상의 흐름을 놓고 보면 각각의 결과를 통해 BARF 결과가 갖는 의의를 볼 수 있다. Positional encoding이 들어가지 않은 NeRF는 alignment를 나름 잘 해냈으나, fine detatil을 살리는 representation에는 좋지 못한 성능을 보였다. 반면에 Full positional encoding을 돌린 NeRF는 fine detail을 잘 살리는 representation 결과를 빠르게 얻었으나, alignment 결과는 많이 어긋남을 볼 수 있다. 이 둘을 비교함으로써 입력 차원의 저차원과 고차원이 갖는 각각의 이점을 파악할 수 있다. 특히 full positional encoding을 보았을 때, fine detail은 BARF보다 더 빨리 살리는 것을 볼 수 있다. \n\r\r 다음 영상은 pose registration 성능 비교를 나타내고 있다. BARF가 NeRF에 비해 빠르게 정답으로 수렴하고 있으며, 심지어 NeRF는 수렴을 하지 못한 결과도 일부 보여주고 있었다. 이러한 결과들을 바탕으로 synthetic data와 real data에서 BARF를 돌린 실험 결과는 아래 이미지들을 통해 확인할 수 있다. \n\r\r\n\r\r\n\r\r\nConclusion BARF는 Image alignment 이론에서 출발한 개념을 잘 녹여내어 representation과 pose registration을 동시에 최적화하는 방법을 제안했다. Bundle-adjusting이라는 이름이 들어간 이유는 최초의 컨셉인 alignment에서의 비선형 최적화 식이 bundle adjustment에서의 최적화 공식과 유사한 형태를 지니기 때문이지 않을까 싶었다. 추가로 제안했던 Coarse-to-fine positional encoding 방법은 결과적으로 registration과 reconstruction을 동시에 수행하기에는 매우 효율적이었다. 한계점으로는 기존 NeRF와 동일한 slow optimization \u0026amp; rendering, rigidity assumption 등을 지적하고 있는데, 아무래도 그런 문제들보다 pose registration에 집중해서 개선 방안을 제안했기 때문에 해당 문제들에 대해서는 당연하겠지만 남아있을 수 밖에 없는 것으로 보인다. 논문에서도 결국 기존에 남아있던 문제를 추가로 해결하기 위해서는 해당 문제들을 개선한 방법들과의 결합을 이야기하고 있는데, 그런 측면에서 BARF는 타 알고리즘에 녹여내기 쉽다라는 이점이 있다고 주장하고 있다.\n","date":"February 17, 2023","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/posts/nerf/barf/","summary":"해당 논문에 대한 리뷰 영상은 아래 동영상을 통해서도 확인하실 수 있습니다.   \nIntro  \nOriginal NeRF 논문은 처음 ECCV 2020에서 발표되었을 때, 뉴럴 렌더링 부분에 있어 굉장히 큰 화두가 되었다. 그와 동시에 많은 한계점들을 가지고 있어서 많은 연구자들로부터 그 문제점들이 지속적으로 지적되어 왔다. 이번에 리뷰할 BARF 논문에서는 그 중에서 Original NeRF가 입력 데이터로 정확한 Camera pose를 요구하고 있다는 점을 지적하고 있는데, 다시 말하면 입력 이미지 데이터와 한 쌍으로 있을 transformation 값이 부정확하거나 알 수 없을 경우에는 뉴럴 렌더링의 정확도가 떨어지게 된다는 것이다.","tags":["Deep Learning","Neural Network","Neural Rendering","Pose Estimation","NeRF","Bundle Adjustment"],"title":"BARF : Bundle-Adjusting Neural Radiance Fields"},{"categories":["Neural Networks"],"contents":"처음 회사에서 인공지능 업무를 배정받기 이전에, 기본적인 CNN 구조에 대해 확실히 알고 가야 제대로 활용할 수 있겠다는 이야기를 듣고 CNN 구조부터 확실히 짚어가기 위해 기본적인 구조에 대한 학습을 시작했다. 이 포스트는 사내에서 세미나를 진행했던 CNN 기초를 다시 복습할 겸 저장하는 블로그 글이다. 사실 세미나를 진행한 시기는 올해 초이기 때문에 굉장히 오래됐고, 글 자체도 그 때 당시에 정리했던 ppt나 노션 등을 나름 잘 정리해서 적어보는 글인데, 누락된 부분이나 잘못 적거나 부실하게 설명한 부분이 있을 수 있다. (그런 부분들에 대해서는 댓글로 지적해주시면 수정하도록 하겠습니다!)\n\nPerceptron   CNN이 본격적으로 활용되기 이전에 뉴럴 네트워크를 통해 image classification 등의 문제를 풀 때는 주로 perceptron 구조를 사용했다. 특정 차원의 벡터로 이루어진 입력이 들어오면 이 것을 여러 층의 hidden layer를 거쳐 출력 값을 내놓는 구조가 Multi layer perceptron이다. 여기서 이 다중 레이어의 퍼셉트론이라는 구조가 왜 나왔는지가 중요한데, 우리가 일반적으로 선형 함수로 되어 있는 특정 문제를 풀기 위해서는 단일 레이어내에 정의된 함수를 통과하면 원하는 값을 도출할 수 있을 것이다.\n\n그러나, 실제로 우리가 풀어야 할 무수히 많은 문제들은 선형 함수만으로는 풀 수 없는 비선형성을 갖는 것들이 매우 많다. 그렇다면 선형 문제를 풀기 위해 정의된 하나의 layer를 통해서는 이 비선형 문제를 풀기가 어렵다는 소리가 된다. 이를 풀기 위한 접근법이 다중 레이어를 통한 접근 방법이라 이해하면 좋을 것이다.\n\n 좀 더 쉽게 설명하자면, 논리 게이트의 XOR Problem을 보면 좋다. 일반적인 논리 게이트를 AND, OR, NOT에 대한 게이트는 쉽게 볼 수 있는데, XOR 문제의 경우 단일 게이트로 이를 표현하기 어렵다는 문제가 있다. 따라서 XOR 문제를 논리 회로로 표현하기 위해서는 위 그림처럼 OR Gate와 NAND, AND gate들을 잘 조합해야 한다.\n\n 직관적으로 위 표와 그래프를 보면 알 수 있을 것이다. \nAND, OR 문제에 비해 XOR은 결과값을 선형 그래프로 표현하는 것이 매우 어렵다. 결국 이 문제는 비선형성을 표현하는 문제와도 직접적으로 연결되어 있기도 하다. 다중 레이어 퍼셉트론 구조는 이와 같은 고민에서 출발했다고 볼 수 있다.\n\n기본적인 퍼셉트론 구조의 뉴럴 네트워크는 크게 두 가지 문제를 폴기 위한 목적으로 사용될 수 있다. 하나는 분류(Classification) 문제고 다른 하나는 회귀(Regression) 문제이다. 분류 문제는 입력으로 넣은 데이터가 별도로 정의된 클래스들 중 어느 클래스에 해당하는지 식별하는 문제이며, 회귀 문제는 내가 찾은 어떠한 결과가 특정 정답에 해당하는 어떠한 평면과 얼마나 근접한 가를 찾는 문제로 볼 수 있다. 사실 이와 관련된 부분은 모델 정의 뿐만 아니라 각 문제별로 loss function을 어떻게 정의하느냐에 관한 문제와도 연관되어있다.\n\n기존 MLP 방법의 문제점 MLP 구조의 뉴럴 네트워크의 경우, 일반적인 이미지를 입력으로 받아 연산을 수행하기에는 그 기능이 확장됨에 어려움이 있다. 가장 큰 문제는 학습을 위한 weight의 갯수인데, 이는 입력 이미지의 해상도가 크면 클 수록 기하급수적으로 늘어나게 될 것이다. \n예를 들어, CIFAR-10에서 제공되는 이미지처럼 32x32 사이즈의 3채널 이미지가 입력으로 들어오는 경우를 생각해보자. 단일 색상에 대한 픽셀 하나하나가 입력으로 들어간다고 가정할 때, 이 입력이 fully connected layer로 들어가게 되면 하나의 레이어를 거칠 때마다 32 * 32 * 3 = 3072개의 weight를 요구하게 된다. 작은 사이즈의 이미지에서는 이게 문제로 보이지 않을 수 있는데, 만약 입력 해상도가 200x200가 있다고 생각해보자. 그러면 레이어 하나당 200 * 200 * 3 = 120,000개의 weight가 요구된다. 물론 CNN이 본격적으로 image classification 문제를 풀기 위한 솔루션으로 활용되기 시작한 시점에는 224x224 해상도의 영상을 많이 사용했지만, 영상이 HD급 이상으로 올라가게 된다면 한 레이어당 필요하게 되는 weight 갯수개 백만개는 훌쩍 넘어갈 것이고, 이게 또 멀티 레이어로 구성된다면 요구되는 weight 갯수는 감당이 힘들 정도로 늘어날 것이다. weight 수의 증가는 연산량 증가로도 이어질 수 있고, 과적합(overfitting) 문제로까지 이어질 수 있다. 이에 대해서는 다음 포스트에서 자세히 짚어보도록 하겠다.\n\n뿐만 아니라 MLP 구조는 보통 flatten된 1차원 벡터가 입력으로써 들어오게 된다. 이미지가 입력으로 들어왔을 때, 2차원 픽셀로 구성된 이미지를 1차원 벡터 형태로 펴주면 흔히 local 영역에 대한 특성을 잘 잡지 못한다는 문제도 존재하게 된다. 이 문제에 대해서는 CNN의 특징을 보면 왜 문제로 제기되었는지 알 수 있다.\n\nConvolutional Neural Networks 기본적인 CNN 구조는 각각의 히든 레이어가 여러개의 neuron이 1차원 벡터 형태로 쌓여 있는 구조가 아닌 3차원 volume으로 구성되어 있는 구조다. CNN에서는 입력 영상에 대해 각각의 레이어마다 주어진 weight 커널과의 합성곱(convolution)을 수행해 3차원 feature map volume을 출력해주는 구조로, 이미지에 대한 가로, 세로 크기는 줄여가며 각 영역에 대한 특징을 의미론적으로 압축해준 다음 최종적으로 1차원 벡터 형태의 출력을 도출하는 구조다.\n\n\n위 그림에 나와있듯이, CNN은 크게 Feature extraction과 Classification 구조로 나뉘어 있다. Feature extraction에서는 상술한 합성곱 과정을 통해 입력 영상의 해상도는 압축되고, 각 픽셀 영역마다 semantic한 정보들을 여러 dimension에 걸쳐 담아주는 feature map을 만들어낸다. 하나의 레이어 내에는 기본적으로 convolution layer, Activation function, Pooling layer로 구성되어 있다.\n\n1. Convolution layer  convolution layer에서는 입력으로 들어온 map과 해당 layer에 주어져 있는 kernel 간 합성곱 연산을 map 전체 영역에 대해 sliding window 형식으로 수행한다. 여기서의 kernel은 weight 값들로 이루어져있는데, convolution layer의 parameter들은 결국 학습이 가능한 weight로 구성된 kernel들의 집합으로 구성되어 있다고 보면 된다. 가령, 우리가 해당 layer를 거치면서 얻고자 하는 다음 feature map의 channel이 32 channel이라면, kernel은 32 channel 만큼 있다는 뜻이 된다. convolution 과정을 통해 우리는 이 layer에서 해당 kernel에 대한 response를 갖는 결과를 얻게 되며, 입력 map으로부터 각 공간적 위치에서 response를 갖는 결과들로 구성된 feature map을 얻을 수 있다. 여기서 나온 feature map에서 활성화 함수(activation function)을 거치고 나면 최종적으로 Activation map을 얻을 수 있다.\n\n직관적으로 보면 네트워크는 이 kernel을 학습하게 된다는 것을 알 수 있을 것이다. 그럼 각 layer에서의 kernel은 어떠한 response를 얻을 수 있게끔 학습이 될까? 입력 영상이 하나 들어온다고 가정했을 때, 초반부 layer에서는 초기 입력 영상과 유사한 스케일의 map을 얻게 될 테니 영상 내 local한 영역에서의 edge나 pattern 등에 대한 부분을 보며 response가 발생하는 activation map을 얻을 것이다. 후반부로 갈 수록 output map의 width와 height는 입력 대비 많이 작아질 것이다. 반복적인 convolution 연산을 통해 이제 activation map은 초반부 대비 local한 영역에서의 response에는 주목할 수 없고, 픽셀 영역 하나하나가 이전보다 더 추상적이고 semantic한 정보를 담는 형태로 map을 만들어낼 것이다. 이러한 특성 때문에 초반부 convolution layer에서는 local한 위치에서의 response에 주목할 수 있게 되고(흔히 이 case를 localization이라고 이야기하는 경우가 많았습니다.), 후반부 layer에서는 semantic한 정보에 대한 response에 주목할 수 있게 될 것이다. 아마 이 내용을 보면 CNN이 결국 나중에는 위치 정보에 대한 취약점이 있지 않을까 하는 의문이 들 수 있는데, 이와 관련해서는 차후에 언급하도록 하겠다.\n\n그렇다면 이러한 convolution layer를 왜 쓰는지에 대한 이해가 필요한데, 과연 convolution layer는 fully connected layer 대비 어떠한 강점을 가지고 있는 것일지 알아보도록 하자.\n\nLocal connectivity Convolution 연산은 작은 사이즈의 kernel을 기반으로 연산을 수행한다. 이로 인해 각각의 convolution 연산 결과는 입력으로부터 지역적으로 인접한 부분끼리만 연결되어 그 결과를 도출한다. 여기서 이 지역적으로 인접한 부분에 대한 공간적인 범위를 Receptive field라고 한다. 쉽게 말하면 사실상 kernel size와 동일하다고 보면 되는데, output map의 한 영역이 다루는 내용은 input map 내 유사한 위치에서 kernel size만큼의 영역이라고 이해하면 될 것이다.\n\n 예를 들어, 32 x 32 x 3 크기의 입력이 들어왔다고 가정해보자. 여기에 우리는 원하는 feature map을 얻기 위해 5 x 5 x 5 크기의 kernel을 이용해 convolution 연산을 적용한다. kernel의 channel이 5이기 때문에 출력의 한 영역에는 5개의 neuron 값을 갖게 될 것이고, 이 5개의 neuron들은 5 x 5 x 3 영역에 대한 weight를 기반으로 그 값을 얻어낼 것이다. 결과적으로 이 5개의 neuron은 동일한 receptive field 영역을 보게 될 것이다.\n\nSpatial arrangement 그렇다면 과연 convolution 이후의 output layer에는 몇 개의 neuron이 어떤 형태로 배열되어 있을까?\n\noutput layer의 크기를 좌우하는 요인으로는 kernel의 size(f)와 channel(K)과 stride(s), 그리고 padding(p)이 있다. 여기서 stride는 kernel을 sliding하면서 연산을 할 때, 그 sliding의 step을 의미하는 hyper-parameter이고, padding은 입력의 가장자리 영역을 0 값으로 채워 입력 대비 output layer의 크기가 줄어들지 않을 수 있는 역할을 하는 hyper-parameter다. 이를 토대로 보통 output layer의 크기는 ( ( (w - f + 2p) / s) + 1) x ( ( (h - f + 2p) / s) + 1) x K 라고 정리할 수 있다. (여기서, w와 h는 input의 width와 height를 의미합니다.) 문제는 이 공식이 맞는 공식인지가 확인이 필요하다. \n 1차원의 입력과 kernel이 있다고 가정해보자. 이 그림을 보면 kernel의 크기가 3으로 할당되어 있고, input의 크기가 7인 것을 확인할 수 있다. 여기서 입력의 양 끝단이 0인 것을 볼 수가 있는데, 이는 입력에 padding 값을 주었기 때문이다. 따라서 이 입력은 padding=1이라는 설정 하에 양 끝단에 padding을 준 입력 값이라는 것을 알 수가 있고, 결론적으로 우리는 원본 input은 크기가 5라는 것을 확인할 수 있다. 그림의 왼쪽을 보면 sliding step이 한 칸씩 진행되는 연산임을 볼 수가 있어 여기서 설정된 stride는 1이라는 것도 확인되었다. 그럼 이제 이 값들을 토대로 위에서 언급한 공식에 대입해보자.\n( (w - f + 2p) / s) + 1 ) = ( (( 5 - 3 + 2*1 ) / 1) + 1 ) = 5\r\r결과적으로 그림의 왼쪽과 같이 값이 5가 나왔으니 이 공식이 성립함을 알 수가 있다. 마찬가지로 그림의 오른쪽 부분대로 stride를 2로 주면 공식에 따라 output 크기 값이 3이라는 것도 확인되었다.\n\n여기서 주의해야 할 점은 위에 언급한 hyper-parameter 들은 상호간에 연관성이 있다는 점이다. 하나의 예로 크기가 10인 1차원 input이 들어왔다고 해보자. 여기서 hyper-parameter 값들이 f = 3, p = 0, s = 2라고 해보자. 공식대로 대입을 하면 (((10 - 3) / 2) + 1) = 4.5가 나오게 된다. 이 말은 즉, 공식대로 계산을 하면 output size가 자연수가 나오지 않는다는 문제가 발생한다. 소숫점이 나왔다라는 것은 결론적으로 나눗셈 연산이 들어가는 stride 쪽의 영향이 크게 작용했다라는 것을 알 수가 있는데, 이 때문에 나머지 hyper-parameter 값들에 따라 stride 값을 잘 주어야 한다는 제약 사항이 생기게 된다. \nParameter sharing Parameter sharing은 CNN의 특장점 중 하나다. 하나의 kernel map을 이용해서 영역별로 sliding window 형태로 계산을 하기 때문에 입력의 각 영역별로 서로 다른 weight를 준비해야하는 부담이 덜하게 된다. 여기서 kernel의 channel이 32라고 하면, kernel에는 32개의 unique한 weight set을 갖는다고 볼 수 있다. CS231n 블로그 내에 적힌 설명을 보면 전체 layer 중 하나의 channel에 있는 하나의 slice를 depth slice라 이야기하고 있다. 가령 55 x 55 x 64의 map이 하나 있다고 가정하면 이 map은 55 x 55 크기의 depth slice가 64장이 있는 것이다. 단위를 이와 같이 나누어 설명하자면, 각각의 depth slice에 있는 모든 뉴런들은 kernel 내에 있는 같은 파라미터들을 사용한다고 이해하면 된다.\n\n 위 그림은 AlexNet에서 첫 convolution layer에 사용하는 96개의 11 x 11 x 3 필터들이라고 한다. 그림을 보면 대각 성분에 대한 필터를 갖기도 하고, 어떤 패턴처럼 생긴 필터나 색상 변화를 나타내는 필터 등등\u0026hellip; 그 각각의 필터들이 주목하는 특성들을 알 수가 있다. 첫 번째 필터를 예를 들어보자. 입력 영상의 어떠한 영역에서 이 첫 번째 필터를 넣었을 때, 중요한 결과가 나온다면 이는 이미지 상 다른 위치에서도 유용해야만 한다. 이는 보통 이미지가 Translationally-invariant한 구조를 갖기 때문이라고 하는데, 이로 인해 위 사진의 첫 번째 필터에 대해 관련된 성분을 검출하기 위해 모든 이미지 영역에 대해 일일히 parameter를 재학습할 필요가 없음을 의미한다. 특히, 입력 이미지가 특정한 중심 구조를 가지는 경우, 이미지의 다른 면에서 완전히 다른 특징을 학습해야 한다는 이야기도 있다. 사실 이 구절만을 직역해서 읽어보면 무슨 이야기인지 알기가 쉽지 않았는데, 이미지 중앙에 얼굴이 있는 입력 이미지를 예로 들어서 생각해보았다. 외형적으로 사람의 눈과 머리는 다른 위치에 있다라는 것을 우리는 직관적으로 알 수 있다. 따라서 하나의 필터를 통과한다면 눈에 특화된 특징과 머리에 특화된 특징은 공간적으로 각각 다른 위치에서 학습되어야만 할 것이다. 이는 즉, 이미지가 지역적인 부분마다 다른 특화된 특징을 내놓을 수 있어야 한다는 것을 의미한다고 볼 수 있고, 이러한 부분 때문에 Convolution layer는 locally-connected layer라고도 할 수가 있다. \u0026amp;\u0026amp; \n요약하자면,\n  처음 입력 크기가 w x h x d인 영상이 들어왔다고 가정해보자 (여기서 d는 보통 영상의 채널 수가 될 것이다.)\n  Convolution layer에서 요구하게 되는 hyper-parameter는 K(kernel의 channel), f(kernel의 size. width와 height가 될 것이다.), s(stride), p(padding)이 된다.\n  하나의 convolution layer를 거치고 나오는 출력 map의 크기는 ( ( (w - f + 2p) / s) + 1) x ( ( (h - f + 2p) / s) + 1) x K 가 된다.\n  하나의 kernel당 f x f x d개의 weight가 포함되어 있고, 해당 kernel이 sliding window 형태로 옮겨가며 연산되기 때문에 영상의 전체 영역에 대해 weight는 공유된다고 할 수 있다. (Parameter sharing)\n  위에 언급한 Parameter sharing때문에 Convolution layer는 Fully connected layer 대비 weight가 적게 요구된다.\n  하나의 layer에서 필요한 총 parameter 갯수는 weight = f x f x d x K, bias = K개다.\n  출력 레이어 내에서 d번째 depth slice는 d번째 kernel과 input layer 간 유효한 Convolution 연산을 수행한 결과다!\n  \r\r\n2. Pooling layer CNN에서는 이전 레이어에서 연산된 결과 map을 토대로 정보를 좀 더 모아 이전 레이어 대비 더 작은 사이즈로 down-sampling하는 목적으로 pooling layer를 사용한다. 특히, 초창기 CNN이 나오던 시기에는 convolution layer 사이사이에 pooling layer를 넣는 것이 거의 공통적이기도 했다. Pooling layer를 사용하게 되면 down-sampling 효과를 가져올 뿐만 아니라 이로 인해 네트워크 계산량과 파라미터 수를 줄여주기도 하고, 파라미터 갯수가 줄기 때문에 오버피팅 컨트롤 역할도 할 수 있다는 주장도 있다(아무래도 파라미터 갯수와 오버핏팅의 상호 관계에서 비롯된 이야기이지 않을까 싶습니다. 오버핏팅에 관한 이야기는 차후에 자세히 다루어 보겠습니다.). 이러한 Pooling layer는 각각의 depth slice에서 독립적으로 동작한다. 따라서 입력의 channel에는 영향을 주지 않으며, 입력에 대해 고정된 함수를 사용하기 때문에 별도의 파라미터도 없고, padding 값도 따로 할당하지 않는다.\n\n 대표적으로는 Average pooling과 Max pooling을 사용한다. Average pooling은 pooling을 적용할 filter 크기 내에 속한 값들의 평균을 output으로 출력하는 방법이고, max pooling은 이들 중 가장 큰 값을 output으로 출력하는 방법이다. pooling 방법에 대한 추세를 보면 오래 전에는 average pooling을 자주 사용해왔지만, 선호도가 차츰 max pooling으로 치우쳐갔다고 한다. 더 나중의 이야기인데, 이 max pooling도 사실상 영역 내 최댓값만 보기 때문에 다른 값들은 보지 않게 되어 이로 인해서 또 오버핏팅이 야기하는 경우도 있었다고 한다. 나중에 Pooling layer 자체를 제거하기 시작한 이유이기도 한데, 이에 관해서는 후발 연구들을 보며 확인을 해야겠다.\n\nPooling layer의 back-propagation  위 그림은 Max pooling의 역전파 과정을 나타낸다. 뒷 레이어로부터 역전파된 gradient 값이 각각 delta_1, delta_2라고 할 때, 역전파를 통해 이전 영역으로 전파된 값을 delta_11, delta_12, delta_21, delta_22라고 하자. 그림 상에서는 max pooling이 두 개의 neuron으로부터 나온 결과로 표현되어 있다. 즉, max pooling은 두 개의 neuron 값 들로부터 가장 큰 값을 가져오게 된다는 말이다. 만약 윗 neuron 값이 max 값이어서 해당 값만을 pooling을 통해 가져왔다면 아랫 neuron은 사실상 의미가 없는 값이나 다름없게 된다. 따라서 이 pooling에 대해 반대로 역전파를 하게 되었을 땐 max 값이 있던 neuron에 대해서만 local gradient 가중치를 1로 주어 이전 delta 값을 역전파시키고, 다른 neuron에 대해서는 local gradient 가중치를 0으로 주어 이전 delta 값을 역으로 전달하지 않게 된다. (사실 이 부분을 읽으면서 들었던 의문점은 max 값이 어디서부터 온 것인지 그 위치에 대한 정보도 결국 기억해야 하는가라는 의문이 생겼습니다. 제가 그 과정 하나하나에 대한 이해가 짧아서 그럴 수 있는데, 아시는 분 댓글로 알려주시면 감사하겠습니다 ㅠㅠ) \n 반대로 average pooling은 평균 값을 기반으로 pooling을 수행하기 때문에 local gradient 값도 전체 neuron 갯수를 나눈 만큼이 된다. 평균을 구하는 공식이 있다고 할 때, 평균 공식에 대해 미분을 하면 결국 1/m만 남기 때문이다. 당연하겠지만, 단순히 뒷 레이어로부터 나온 gradient 값에 local gradient 값만 곱하면 나온다고 정리가 된 이유는 Back-propagation이 Chain rule 원리에 따라 값이 전파되기 때문이다.\n\n3. Fully connected layer 앞 단에서 feature map을 만들어내면 해당 map이 classification을 위한 fully connected layer에 입력으로 들어가 최종적으로 하나의 vector를 만들어낸다. 이 vector는 최종적으로 풀고자 하는 classification에 대한 class 갯수만큼, 그 class 각각의 확률을 의미하는 값을 포함하고 있다. 기본적인 구조 자체는 Multi layer perceptron과 유사하기 때문에 자세한 설명은 생략하도록 하겠다. \n4. Basic architecture 기본적으로 CNN 내에서의 convolution layer는 convolution 연산을 위한 kernel과 activation function 순서로 구성되어 있다. 이 뒤에 필요에 따라 pooling layer가 붙는 구조다. Activation function에는 보통 ReLU를 많이 쓰는 편인데, 목적에 따라 Leaky ReLU, ELU 등등 여러 선택지가 있다. Feature extraction을 수행하는 부분에서는 이러한 [Conv - ReLU - Pool] 구조가 반복적으로 배치되어 최종적으로는 입력 영상 대비 가로, 세로 크기가 많이 줄어들고 그 각각에 semantic한 특징을 내포하고 있는 feature map을 만들어낸다. 어느 정도 원하는 크기의 feature map을 얻게 되면 여기 있는 값들을 flatten시켜 1차원의 vector꼴로 변환하는데, 이 vector 형태의 입력이 여러 차례의 fully connected layer를 거치고, 최종적으로 class score를 출력해준다. 여기서의 class score는 우리가 classification 문제를 풀기 위해 사전에 정의한 class들에 대해 해당 영상이 특정 class에 해당할 확률을 나타낸다. 기본적인 예제에서는 1000개의 값을 갖는 class score vector를 출력한다고 설명이 되어있는데, 이는 1000개의 class에 대한 classification 확률을 뽑기 위함이라고 보면 된다.\n\n조금 더 살펴보자면, CNN의 전체 구조는 보통 다음과 같은 흐름으로 되어있다 볼 수 있다.\n  [INPUT] - [FC]\n  [INPUT] - [CONV] - [ReLU] - [FC]\n  [INPUT] - {[CONV] - [ReLU] - [POOL]} * n - [FC] - [ReLU] - [FC]\n  [INPUT] - {[CONV] - [ReLU] - [CONV] - [ReLU] - [POOL]} * n - {[FC] - [ReLU]} * n - [FC]\n  \r\r\n1번과 같은 구조는 여러 레이어가 쌓여 있는 형태가 아니기 때문에 보통 선형 분류에 대한 문제를 풀 때 사용할 수 있는 간단한 구조다. 3번과 4번 구조가 기본적으로 다수의 [Conv - ReLU - Pool] 구조가 반복되는 형태인데, 4번이 3번과 달리 Conv - ReLU가 한 차례정도 더 나오고 Pooling을 진행하는 구조로 되어 있다. 이는 다수의 convolution layer를 통과했을 때, 더 복잡한 feature를 얻을 수 있다는 이점이 있기 때문이다. 이런 다음에 pooling을 진행하면 동일하게 down-sample된 feature map에 대해 3번보다 더 복잡한 특징 정보들을 많이 얻을 수 있을 것이다.\n\n각 파트에 대해 빠진 설명들이 일부 존재하는데, 이는 다음 포스트를 통해 추가로 언급해보도록 하겠다. \n","date":"August 4, 2022","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/posts/neural_networks/cnn_basics/","summary":"처음 회사에서 인공지능 업무를 배정받기 이전에, 기본적인 CNN 구조에 대해 확실히 알고 가야 제대로 활용할 수 있겠다는 이야기를 듣고 CNN 구조부터 확실히 짚어가기 위해 기본적인 구조에 대한 학습을 시작했다. 이 포스트는 사내에서 세미나를 진행했던 CNN 기초를 다시 복습할 겸 저장하는 블로그 글이다. 사실 세미나를 진행한 시기는 올해 초이기 때문에 굉장히 오래됐고, 글 자체도 그 때 당시에 정리했던 ppt나 노션 등을 나름 잘 정리해서 적어보는 글인데, 누락된 부분이나 잘못 적거나 부실하게 설명한 부분이 있을 수 있다.","tags":["Deep Learning","Neural Network"],"title":"CNN의 기본적인 구조 및 원리 - 1"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://Philipshrimp.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"}]